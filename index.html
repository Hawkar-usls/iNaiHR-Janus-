<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#030508">
    <title>HRAIN v4.0: Janus Graph Explorer</title>
    
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;600;700&family=Orbitron:wght@600;800&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-dark: #030508;
            --bg-pulse: #0b101a;
            
            /* NEON PALETTE */
            --c-default: #00ffa3; 
            --c-danger: #ff2a6d;
            --c-warn: #ffc107;
            --c-info: #d300ff;

            /* DYNAMIC AMBIENT COLOR */
            --c-ambient: #00ffa3; 

            --glass: rgba(255, 255, 255, 0.05);
            --border: rgba(255, 255, 255, 0.15);
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: var(--bg-dark);
            font-family: 'Rajdhani', sans-serif; color: #e0e0e0;
            user-select: none; touch-action: none; position: fixed;
        }

        /* --- ATMOSPHERE --- */
        #neural-bg {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 50% 50%, var(--bg-pulse), var(--bg-dark));
            z-index: 0; animation: breathe 12s infinite alternate ease-in-out; pointer-events: none;
        }
        @keyframes breathe { 0% { opacity: 0.6; transform: scale(1); } 100% { opacity: 1; transform: scale(1.1); } }

        #particles { position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 0; }
        
        .particle {
            position: absolute; 
            background: var(--c-ambient);
            border-radius: 50%;
            opacity: 0.3; 
            animation: float 30s infinite linear;
            box-shadow: 0 0 10px var(--c-ambient);
            transition: background-color 3s ease, box-shadow 3s ease;
        }
        
        @keyframes float { 
            0% { transform: translateY(0) translateX(0); opacity: 0; } 
            50% { opacity: 0.5; } 
            100% { transform: translateY(-100vh) translateX(40px); opacity: 0; } 
        }

        #grid-bg {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-size: 50px 50px; opacity: 0; transition: opacity 0.5s, background-image 3s ease; z-index: 1; pointer-events: none;
        }
        body.grid-active #grid-bg { opacity: 1; }

        /* --- UI LAYER --- */
        .ui-layer { position: fixed; z-index: 20; pointer-events: none; width: 100%; height: 100%; top: 0; left: 0; }
        .ui-interactive { pointer-events: auto !important; }

        #logo {
            position: absolute; top: 30px; left: 30px;
            font-family: 'Orbitron'; font-size: 1.4rem; letter-spacing: 2px;
            color: rgba(255,255,255,0.3); text-shadow: 0 0 15px rgba(0, 255, 163, 0.2);
            cursor: pointer;
        }
        #logo span { color: var(--c-default); }

        .top-controls {
            position: absolute; top: 30px; right: 30px;
            display: flex; gap: 8px; flex-wrap: wrap; justify-content: flex-end;
            max-width: 80%; 
        }

        .btn {
            background: rgba(10, 15, 20, 0.7); border: 1px solid var(--border);
            color: rgba(255,255,255,0.8); backdrop-filter: blur(8px);
            padding: 10px 16px; border-radius: 8px;
            font-family: 'Rajdhani', sans-serif; font-weight: 700; font-size: 0.85rem;
            cursor: pointer; transition: 0.1s; text-transform: uppercase; letter-spacing: 1px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            display: flex; align-items: center; justify-content: center;
        }
        .btn:active { transform: scale(0.92); background: rgba(0, 255, 163, 0.1); border-color: var(--c-default); color: #fff; }
        .btn.active { border-color: var(--c-default); color: var(--c-default); background: rgba(0, 255, 163, 0.15); box-shadow: 0 0 15px rgba(0, 255, 163, 0.2); }
        .btn.loading { border-color: var(--c-info); color: var(--c-info); background: rgba(211, 0, 255, 0.1); pointer-events: none; animation: pulse-btn 1s infinite alternate; }
        .btn.success { border-color: var(--c-default); color: var(--c-default); background: rgba(0, 255, 163, 0.2); }
        
        @keyframes pulse-btn { 0% { box-shadow: 0 0 5px var(--c-info); opacity: 0.7; } 100% { box-shadow: 0 0 20px var(--c-info); opacity: 1; } }

        /* DIVE BUTTON */
        #btn-dive {
            position: absolute; bottom: 40px; left: 30px;
            border-color: var(--c-default); color: var(--c-default);
            font-family: 'Orbitron'; font-size: 1rem; padding: 12px 20px;
            box-shadow: 0 0 20px rgba(0, 255, 163, 0.1);
            opacity: 0; transform: translateY(20px); transition: 0.4s; pointer-events: none;
            background: rgba(0, 20, 10, 0.9);
        }
        #btn-dive.visible { opacity: 1; transform: translateY(0); pointer-events: auto; }

        #nav-context {
            position: absolute; top: 80px; left: 30px;
            display: flex; flex-direction: column; gap: 8px; opacity: 0; transition: 0.3s;
        }
        #nav-context.visible { opacity: 1; }
        .crumb { font-size: 0.85rem; color: #888; display: flex; align-items: center; gap: 5px; cursor: pointer; }
        .crumb:hover { color: #fff; text-decoration: underline; }
        .crumb.active { color: var(--c-default); font-weight: bold; text-shadow: 0 0 10px rgba(0,255,163,0.4); cursor: default; text-decoration: none; }
        #btn-ascend {
            padding: 6px 12px; font-size: 0.75rem; 
            border: 1px solid var(--c-default); background: rgba(0,0,0,0.6);
            color: var(--c-default); width: fit-content; margin-top: 5px;
        }

        /* MAIN BUTTON (+) */
        #main-btn {
            position: absolute; bottom: calc(40px + env(safe-area-inset-bottom)); left: 50%; transform: translateX(-50%);
            width: 72px; height: 72px; border-radius: 50%; border: none;
            background: radial-gradient(circle at 40% 40%, rgba(40,40,40,0.5), rgba(0,0,0,0.95));
            box-shadow: 0 0 0 1px var(--border), 0 10px 30px rgba(0,0,0,0.6);
            backdrop-filter: blur(10px); display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.3s; -webkit-tap-highlight-color: transparent;
        }
        #main-btn::after { content: '+'; font-size: 32px; font-weight: 300; color: var(--c-default); transition: 0.3s; text-shadow: 0 0 10px var(--c-default); }
        #main-btn:active { transform: translateX(-50%) scale(0.9); }
        
        #main-btn.mode-edit { box-shadow: 0 0 0 2px var(--color-target, var(--c-default)), 0 0 50px var(--color-target, var(--c-default)); }
        #main-btn.mode-edit::after { content: '‚úé'; color: #fff; text-shadow: none; }
        
        #main-btn.holding-delete { box-shadow: 0 0 0 2px var(--c-danger), 0 0 60px var(--c-danger); transform: translateX(-50%) scale(1.1); }
        #main-btn.holding-delete::after { content: '√ó'; color: var(--c-danger); }

        /* FILTER BAR */
        #filter-bar {
            position: absolute; top: 110px; left: 30px;
            display: flex; gap: 10px; flex-wrap: wrap;
            background: rgba(5, 8, 12, 0.8); backdrop-filter: blur(8px);
            padding: 12px 20px; border-radius: 12px; border: 1px solid var(--border);
            max-width: calc(100% - 100px);
        }
        #filter-bar select, #filter-bar input {
            background: rgba(0,0,0,0.5); border: 1px solid var(--border);
            color: #fff; padding: 8px 12px; font-family: 'Rajdhani'; font-weight: 600;
            border-radius: 6px; outline: none; cursor: pointer;
        }
        #filter-bar option { background: var(--bg-dark); }
        #filter-bar input::placeholder { color: #aaa; }
        #sync-progress {
            color: var(--c-info); font-size: 0.85rem; margin-left: 10px; align-self: center;
        }

        /* --- NOTIFICATIONS --- */
        #toast-container {
            position: fixed; bottom: 120px; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column; gap: 10px; pointer-events: none; z-index: 4000;
            width: 90%; max-width: 350px;
        }
        .toast {
            background: rgba(10, 15, 20, 0.95); border: 1px solid var(--border);
            color: #ddd; padding: 12px 16px; border-radius: 8px;
            font-family: 'Rajdhani'; font-weight: 600; font-size: 0.9rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5); backdrop-filter: blur(5px);
            opacity: 0; transform: translateY(20px); transition: 0.3s; text-align: center;
        }
        .toast.visible { opacity: 1; transform: translateY(0); }
        .toast.error { border-color: var(--c-danger); color: var(--c-danger); box-shadow: 0 0 15px rgba(255, 42, 109, 0.2); }

        /* --- VISUALS --- */
        #chart { width: 100%; height: 100%; position: relative; z-index: 1; }
        
        .link { 
            fill: none; 
            stroke-width: 2.5px; 
            opacity: 0.7;
            transition: 0.3s; 
            filter: drop-shadow(0 0 3px currentColor);
        }
        .impulse { filter: drop-shadow(0 0 8px currentColor); pointer-events: none; mix-blend-mode: screen; opacity: 0.7; }
        
        @keyframes core-pulse { 0% { filter: drop-shadow(0 0 5px var(--node-color)); stroke-width: 2px; } 50% { filter: drop-shadow(0 0 15px var(--node-color)); stroke-width: 3px; } 100% { filter: drop-shadow(0 0 5px var(--node-color)); stroke-width: 2px; } }
        @keyframes aura-spin { 0% { opacity: 0.2; transform: scale(0.95); } 50% { opacity: 0.5; transform: scale(1.1); } 100% { opacity: 0.2; transform: scale(0.95); } }
        @keyframes select-spin { 0% { transform: rotate(0deg) scale(1.1); } 100% { transform: rotate(360deg) scale(1.1); } }

        .neuron-core { 
            fill: var(--node-bg, rgba(0,255,163,0.15)); 
            stroke-width: 2px; transition: 0.3s;
            stroke: var(--node-color, #00ffa3);
            animation: core-pulse 4s infinite ease-in-out;
        }
        .neuron-aura {
            fill: transparent; stroke: var(--node-color, #00ffa3); stroke-width: 1px; opacity: 0.3;
            transform-origin: center; transform-box: fill-box;
            animation: aura-spin 6s infinite ease-in-out;
        }
        
        /* HERO SELECTION */
        .node-group.selected .neuron-core { 
            stroke: #fff; 
            filter: drop-shadow(0 0 10px var(--node-color)) drop-shadow(0 0 20px var(--node-color)); 
            stroke-width: 3px;
        }
        .node-group.selected .neuron-aura { 
            opacity: 0.8; 
            stroke-width: 2px;
            stroke-dasharray: 10, 5;
            animation: select-spin 10s infinite linear; 
        }
        
        .node-group.is-root .neuron-core { stroke-width: 4px; fill: rgba(255,255,255,0.1); }

        text.emoji { font-size: 24px; text-anchor: middle; dominant-baseline: central; pointer-events: none; }
        text.label { font-family: 'Rajdhani'; font-size: 13px; font-weight: 700; fill: rgba(255,255,255,0.9); text-anchor: middle; pointer-events: none; text-shadow: 0 2px 5px #000; transition: 0.3s; }

        .type-default { --node-color: var(--c-default); --node-bg: rgba(0, 255, 163, 0.15); }
        .type-danger { --node-color: var(--c-danger); --node-bg: rgba(255, 42, 109, 0.15); }
        .type-warn { --node-color: var(--c-warn); --node-bg: rgba(255, 193, 7, 0.15); }
        .type-info { --node-color: var(--c-info); --node-bg: rgba(211, 0, 255, 0.15); }

        /* --- MODALS --- */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(12px);
            z-index: 3000; display: none; align-items: center; justify-content: center;
        }
        .modal-box {
            width: 80%; max-width: 280px; padding: 25px; background: #080c10;
            border: 1px solid var(--border); box-shadow: 0 0 50px rgba(0,255,163,0.1);
            text-align: center; border-radius: 16px;
        }
        #rename-input {
            width: 100%; background: transparent; border: none; border-bottom: 2px solid var(--c-default);
            color: #fff; font-size: 1.5rem; text-align: center; padding: 10px; margin-bottom: 20px; outline: none;
            font-family: 'Orbitron';
        }
        #btn-confirm { width: 100%; padding: 12px; font-size: 1rem; letter-spacing: 2px; border-color: var(--c-default); color: var(--c-default); }

        #chat-panel {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 70%;
            background: rgba(5, 8, 12, 0.98); border-top: 1px solid var(--c-default);
            z-index: 3500; transform: translateY(100%); transition: 0.3s; display: flex; flex-direction: column;
        }
        #chat-panel.open { transform: translateY(0); }
        #chat-msgs { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 15px; }
        .msg { padding: 12px; border-radius: 8px; font-size: 0.95rem; max-width: 85%; line-height: 1.4; }
        .msg.ai { align-self: flex-start; background: rgba(0,255,163,0.1); border-left: 2px solid var(--c-default); color: #ddd; }
        .msg.user { align-self: flex-end; background: rgba(255,255,255,0.1); color: #fff; text-align: right; }
        
        #delete-hint {
            position: fixed; bottom: calc(130px + env(safe-area-inset-bottom)); left: 50%; transform: translateX(-50%);
            color: var(--c-danger); font-size: 0.85rem; letter-spacing: 2px; font-weight: 700; 
            opacity: 0; pointer-events: none; transition: 0.3s; z-index: 50;
        }
        #delete-hint.visible { opacity: 1; transform: translateX(-50%) translateY(-10px); }
    </style>
</head>
<body>

    <div id="neural-bg"></div>
    <div id="particles"></div>
    <div id="grid-bg"></div>

    <div class="ui-layer">
        <div id="logo">HR<span>ai</span>N</div>
        
        <div id="nav-context" class="ui-interactive">
            <div id="breadcrumbs"></div>
            <button id="btn-ascend" class="btn" onclick="ascend()">‚ñ≤ ASCEND</button>
        </div>

        <div class="top-controls ui-interactive">
            <button id="btn-grid" class="btn" onclick="toggleGrid()">GRID</button>
            <button id="btn-chat" class="btn" onclick="toggleChat()">AI CHAT</button>
            <button id="btn-synth" class="btn" onclick="synthNode(this)">SYNTH</button>
            <button id="btn-sync" class="btn" onclick="syncWithGitHub()">SYNC</button>
            <button id="btn-save" class="btn" onclick="exportData(this)">SAVE</button>
            <button id="btn-load" class="btn" onclick="document.getElementById('import-file').click()">LOAD</button>
            <button id="btn-wipe" class="btn" onclick="wipeData(this)">WIPE</button>
        </div>
        
        <!-- Hidden Import Input -->
        <input type="file" id="import-file" style="display:none" accept=".json" onchange="importData(this)">

        <!-- Filter Bar -->
        <div id="filter-bar" class="ui-interactive">
            <select id="filter-version" onchange="applyFilters()">
                <option value="all">ALL VERSIONS</option>
                <option value="v5.2">v5.2</option>
                <option value="v5.4">v5.4</option>
                <option value="v5.5">v5.5</option>
                <option value="v5.6">v5.6</option>
                <option value="v5.7">v5.7</option>
                <option value="v5.8">v5.8</option>
                <option value="v5.9">v5.9</option>
                <option value="v6.3">v6.3</option>
                <option value="v7.2">v7.2</option>
                <option value="v7.3">v7.3</option>
                <option value="v8.3">v8.3</option>
            </select>
            <select id="filter-layer" onchange="applyFilters()">
                <option value="all">ALL LAYERS</option>
                <option value="empirical">EMPIRICAL</option>
                <option value="hypothesis">HYPOTHESIS</option>
            </select>
            <input type="text" id="search" placeholder="SEARCH..." oninput="searchNodes()">
            <span id="sync-progress"></span>
        </div>

        <button id="btn-dive" class="btn ui-interactive" onclick="dive()">DIVE</button>
        <button id="main-btn" class="ui-interactive"></button>
        <div id="delete-hint">DISCONNECTING...</div>
        
        <!-- TOAST CONTAINER -->
        <div id="toast-container"></div>
    </div>

    <!-- MODAL -->
    <div id="rename-modal" class="modal ui-interactive">
        <div class="modal-box">
            <input type="text" id="rename-input" placeholder="VOID..." autocomplete="off" onkeypress="if(event.key==='Enter') confirmRename()">
            <button id="btn-confirm" class="btn" onclick="confirmRename()">CONFIRM</button>
        </div>
    </div>

    <div id="chat-panel" class="ui-interactive">
        <div style="padding:15px; border-bottom:1px solid #333; display:flex; justify-content:space-between; align-items: center;">
            <span style="color:var(--c-default); font-family:'Orbitron'; font-size:1.2rem;">NEURAL LINK</span>
            <button onclick="toggleChat()" style="background:none; border:none; color:#fff; font-size:1.5rem;">√ó</button>
        </div>
        <div id="chat-msgs"></div>
        <div style="padding:15px; background:#000; display:flex;">
            <input id="chat-in" type="text" placeholder="–ó–∞–¥–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å..." style="flex:1; background:#111; border:none; color:#fff; padding:12px; font-family:'Rajdhani';" onkeypress="if(event.key==='Enter') sendChat()">
            <button onclick="sendChat()" style="background:var(--c-default); border:none; padding:0 20px; font-weight:bold; color:#000;">></button>
        </div>
    </div>

    <div id="chart"></div>

    <script>
        // =============================================================================
        // CONFIGURATION & GLOBALS
        // =============================================================================
        const apiKey = ""; // Leave empty to use backend (if any), or insert your Gemini key.
        const BACKEND_URL = ""; // Optional: your Janus backend.

        const isMobile = window.innerWidth < 768;
        const GRID_SIZE = isMobile ? 40 : 60;

        // List of all registry files from the GitHub repo.
        const REGISTRY_FILES = [
            { version: 'v5.2', file: 'janus-meta-registry-v5.2.json', url: 'https://raw.githubusercontent.com/Hawkar-usls/janus-meta-registry/main/janus-meta-registry-v5.2.json' },
            { version: 'v5.4', file: 'janus-meta-registry-v5.4.json', url: 'https://raw.githubusercontent.com/Hawkar-usls/janus-meta-registry/main/janus-meta-registry-v5.4.json' },
            { version: 'v5.5', file: 'janus-meta-registry-v5.5.json', url: 'https://raw.githubusercontent.com/Hawkar-usls/janus-meta-registry/main/janus-meta-registry-v5.5.json' },
            { version: 'v5.6', file: 'janus-meta-registry-v5.6.json', url: 'https://raw.githubusercontent.com/Hawkar-usls/janus-meta-registry/main/janus-meta-registry-v5.6.json' },
            { version: 'v5.7', file: 'janus-meta-registry-v5.7.json', url: 'https://raw.githubusercontent.com/Hawkar-usls/janus-meta-registry/main/janus-meta-registry-v5.7.json' },
            { version: 'v5.8', file: 'janus-meta-registry-v5.8.json', url: 'https://raw.githubusercontent.com/Hawkar-usls/janus-meta-registry/main/janus-meta-registry-v5.8.json' },
            { version: 'v5.9', file: 'janus-ai-integration-v5.9.json', url: 'https://raw.githubusercontent.com/Hawkar-usls/janus-meta-registry/main/janus-ai-integration-v5.9.json' },
            { version: 'v6.3', file: 'janus-meta-registry-v6.3.json', url: 'https://raw.githubusercontent.com/Hawkar-usls/janus-meta-registry/main/janus-meta-registry-v6.3.json' },
            { version: 'v7.2', file: 'janus-human-sync-neuro-v7.2.json', url: 'https://raw.githubusercontent.com/Hawkar-usls/janus-meta-registry/main/janus-human-sync-neuro-v7.2.json' },
            { version: 'v7.3', file: 'janus-human-sync-global-v7.3.json', url: 'https://raw.githubusercontent.com/Hawkar-usls/janus-meta-registry/main/janus-human-sync-global-v7.3.json' },
            { version: 'v8.3', file: 'janus-tectonic-uap-v8.3.json', url: 'https://raw.githubusercontent.com/Hawkar-usls/janus-meta-registry/main/janus-tectonic-uap-v8.3.json' }
        ];

        // Master data store (merged from all registries)
        let masterNodeMap = new Map();      // key: node ID (event_id or generated)
        let masterLinks = [];

        // Current view data (filtered)
        let viewNodes = [], viewLinks = [];

        // Original graph state (for local editing)
        let globalNodes = [], globalLinks = [];
        let contextStack = [], selectedNode = null, rootId = null;
        let isGrid = false;

        // Valid types for CSS
        const VALID_TYPES = ['default', 'danger', 'warn', 'info'];

        // D3 simulation variables
        let width = window.innerWidth, height = window.innerHeight;
        const svg = d3.select("#chart").append("svg").attr("width","100%").attr("height","100%");
        const g = svg.append("g");
        const linkG = g.append("g").attr("class","links");
        const impulseG = g.append("g").attr("class","impulses");
        const nodeG = g.append("g").attr("class","nodes");

        const sim = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.id).distance(isMobile?160:200))
            .force("charge", d3.forceManyBody().strength(-2000))
            .force("collide", d3.forceCollide().radius(110).strength(1).iterations(3))
            .force("x", d3.forceX(width/2).strength(0.01))
            .force("y", d3.forceY(height/2).strength(0.01))
            .velocityDecay(0.6);

        // =============================================================================
        // UTILS: Notifications, Particles, Atmosphere
        // =============================================================================
        function showNotification(text, isError = false) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast ' + (isError ? 'error' : '');
            toast.innerText = text;
            container.appendChild(toast);
            requestAnimationFrame(() => toast.classList.add('visible'));
            setTimeout(() => {
                toast.classList.remove('visible');
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        function initParticles() {
            const c = document.getElementById('particles');
            for(let i=0; i<30; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                p.style.left = Math.random()*100+'%'; p.style.top = Math.random()*100+'%';
                p.style.width = (Math.random()*3+2)+'px'; p.style.height = p.style.width;
                p.style.animationDuration = (Math.random()*15+15)+'s';
                p.style.animationDelay = -(Math.random()*15)+'s';
                c.appendChild(p);
            }
        }
        initParticles();
        document.getElementById('grid-bg').style.backgroundImage = `linear-gradient(rgba(0, 255, 163, 0.06) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 255, 163, 0.06) 1px, transparent 1px)`;

        function updateAtmosphere() {
            if(!viewNodes.length) return;
            const counts = { default: 0, danger: 0, warn: 0, info: 0 };
            viewNodes.forEach(n => {
                let t = n.type || 'default';
                if(!counts[t]) counts[t] = 0;
                counts[t]++;
            });
            let max = -1, dom = 'default';
            for(let t in counts) {
                if(counts[t] > max) { max = counts[t]; dom = t; }
            }
            const colorMap = {
                default: '#00ffa3',
                danger: '#ff2a6d',
                warn: '#ffc107',
                info: '#d300ff'
            };
            const c = colorMap[dom] || '#00ffa3';
            document.documentElement.style.setProperty('--c-ambient', c);
            const rgb = hexToRgb(c);
            if(rgb) {
                document.getElementById('grid-bg').style.backgroundImage = 
                    `linear-gradient(rgba(${rgb}, 0.08) 1px, transparent 1px), linear-gradient(90deg, rgba(${rgb}, 0.08) 1px, transparent 1px)`;
            }
        }

        function hexToRgb(hex) {
            let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : null;
        }

        function animateVisuals() {
            if(Math.random() > 0.95) updateAtmosphere();
            if(viewLinks.length > 0 && Math.random() > 0.85) {
                const l = viewLinks[Math.floor(Math.random()*viewLinks.length)];
                if(l.source.x && l.target.x) animateImpulse(l.source, l.target);
            }
            requestAnimationFrame(animateVisuals);
        }
        animateVisuals();

        function animateImpulse(source, target) {
            if(isNaN(source.x) || isNaN(target.x)) return;
            let t = source.type || 'default';
            if(!VALID_TYPES.includes(t)) t = 'default';
            const color = `var(--c-${t})`;
            const spark = impulseG.append("circle").attr("class", "impulse").attr("r", 4).attr("cx", source.x).attr("cy", source.y).style("fill", "#fff").style("color", color);
            spark.transition().duration(800).ease(d3.easeQuadIn).attr("cx", target.x).attr("cy", target.y).style("fill", color).on("end", function() { d3.select(this).remove(); });
        }

        // =============================================================================
        // MERGING LOGIC (Loader)
        // =============================================================================
        function getEmojiForEvent(item) {
            if (item.event_type?.includes('military')) return '‚öîÔ∏è';
            if (item.event_type?.includes('medical')) return 'üè•';
            if (item.event_type?.includes('volcanic')) return 'üåã';
            if (item.event_type?.includes('neural')) return 'üß†';
            if (item.event_type?.includes('uap')) return 'üõ∏';
            return 'üìÑ';
        }
        function getEmojiForType(type) {
            if (type?.toLowerCase().includes('uap')) return 'üõ∏';
            if (type?.toLowerCase().includes('nuclear')) return '‚ò¢Ô∏è';
            return 'üîπ';
        }

        function mergeRegistry(data, versionTag) {
            // --- Empirical layer from old versions (collections) ---
            if (data.collections) {
                Object.values(data.collections).forEach(collection => {
                    if (collection.sites) {
                        collection.sites.forEach(site => {
                            const nodeId = site.id || `${versionTag}-${site.name}-${Date.now()}`;
                            if (!masterNodeMap.has(nodeId)) {
                                masterNodeMap.set(nodeId, {
                                    id: nodeId,
                                    label: site.name,
                                    type: site.content_matrix?.dominant_subjects?.[0]?.toLowerCase() || 'default',
                                    emoji: getEmojiForType(site.content_matrix?.dominant_subjects?.[0]),
                                    version: versionTag,
                                    layer: 'empirical',
                                    sourceData: site
                                });
                            }
                        });
                    }
                });
            }
            // --- Empirical layer from v6.3+ ---
            if (data.empirical_layer) {
                data.empirical_layer.forEach(item => {
                    const nodeId = item.event_id;
                    if (!masterNodeMap.has(nodeId)) {
                        masterNodeMap.set(nodeId, {
                            id: nodeId,
                            label: item.name || item.event_id,
                            type: item.verification_status === 'confirmed_official' ? 'info' :
                                  (item.verification_status === 'confirmed_military' ? 'warn' : 'default'),
                            emoji: getEmojiForEvent(item),
                            version: versionTag,
                            layer: 'empirical',
                            sourceData: item
                        });
                    }
                });
            }
            // --- Hypothesis layer ---
            if (data.hypothesis_layer) {
                data.hypothesis_layer.forEach(hyp => {
                    const nodeId = hyp.event_id;
                    if (!masterNodeMap.has(nodeId)) {
                        masterNodeMap.set(nodeId, {
                            id: nodeId,
                            label: hyp.description?.substring(0, 50) + '...' || hyp.event_id,
                            type: 'info',
                            emoji: 'üß†',
                            version: versionTag,
                            layer: 'hypothesis',
                            sourceData: hyp
                        });
                    }
                    if (hyp.connections_to_other_registries) {
                        hyp.connections_to_other_registries.forEach(conn => {
                            masterLinks.push({
                                source: nodeId,
                                target: conn,
                                type: 'hypothesis'
                            });
                        });
                    }
                });
            }
            // --- Correlation analysis ---
            if (data.correlation_analysis && data.correlation_analysis.matrix) {
                data.correlation_analysis.matrix.forEach(corr => {
                    masterLinks.push({
                        source: corr.source_id,
                        target: corr.target_id,
                        type: corr.type || 'correlation',
                        strength: corr.strength || 0.5
                    });
                });
            }
            // --- Meta links (old versions) ---
            if (data.meta_links) {
                Object.values(data.meta_links).forEach(linkArray => {
                    linkArray.forEach(link => {
                        masterLinks.push({
                            source: link.source,
                            target: link.target,
                            type: 'meta'
                        });
                    });
                });
            }
        }

        async function loadAllRegistries(progressCallback) {
            masterNodeMap.clear();
            masterLinks = [];
            for (let i = 0; i < REGISTRY_FILES.length; i++) {
                const reg = REGISTRY_FILES[i];
                try {
                    const response = await fetch(reg.url);
                    const data = await response.json();
                    mergeRegistry(data, reg.version);
                    if (progressCallback) progressCallback(i + 1, REGISTRY_FILES.length);
                } catch (e) {
                    console.error(`Failed to load ${reg.file}:`, e);
                }
            }
            return {
                nodes: Array.from(masterNodeMap.values()),
                links: masterLinks
            };
        }

        // =============================================================================
        // FILTERING & SEARCH
        // =============================================================================
        function applyFilters() {
            const versionFilter = document.getElementById('filter-version').value;
            const layerFilter = document.getElementById('filter-layer').value;

            let filteredNodes = Array.from(masterNodeMap.values()).filter(node => {
                if (versionFilter !== 'all' && node.version !== versionFilter) return false;
                if (layerFilter !== 'all' && node.layer !== layerFilter) return false;
                return true;
            });

            const filteredNodeIds = new Set(filteredNodes.map(n => n.id));
            const filteredLinks = masterLinks.filter(l => 
                filteredNodeIds.has(l.source) && filteredNodeIds.has(l.target)
            );

            // Convert to format expected by D3 (with x,y)
            viewNodes = filteredNodes.map(n => ({
                ...n,
                x: n.x || width/2 + (Math.random()-0.5)*100,
                y: n.y || height/2 + (Math.random()-0.5)*100
            }));
            viewLinks = filteredLinks;

            // Update globalNodes/globalLinks for editing (optional, we can keep separate)
            globalNodes = viewNodes;
            globalLinks = viewLinks;

            updateView();
            sim.alpha(1).restart();
        }

        function searchNodes() {
            const term = document.getElementById('search').value.toLowerCase();
            if (!term) {
                applyFilters();
                return;
            }
            const allNodes = Array.from(masterNodeMap.values());
            const filteredNodes = allNodes.filter(node => 
                node.label.toLowerCase().includes(term) || (node.id && node.id.toLowerCase().includes(term))
            );
            const filteredNodeIds = new Set(filteredNodes.map(n => n.id));
            const filteredLinks = masterLinks.filter(l => 
                filteredNodeIds.has(l.source) && filteredNodeIds.has(l.target)
            );
            viewNodes = filteredNodes.map(n => ({
                ...n,
                x: n.x || width/2 + (Math.random()-0.5)*100,
                y: n.y || height/2 + (Math.random()-0.5)*100
            }));
            viewLinks = filteredLinks;
            globalNodes = viewNodes;
            globalLinks = viewLinks;
            updateView();
            sim.alpha(1).restart();
        }

        // =============================================================================
        // SYNC WITH GITHUB
        // =============================================================================
        async function syncWithGitHub() {
            const progressSpan = document.getElementById('sync-progress');
            progressSpan.innerText = 'Loading...';
            const result = await loadAllRegistries((current, total) => {
                progressSpan.innerText = `${current}/${total}`;
            });
            // Store in localStorage for offline use
            localStorage.setItem('janus_master_graph', JSON.stringify({
                nodes: result.nodes,
                links: result.links
            }));
            progressSpan.innerText = '';
            showNotification(`Loaded ${result.nodes.length} nodes, ${result.links.length} links`);
            applyFilters(); // Apply default filters to show graph
        }

        // =============================================================================
        // INIT: load saved graph or start from scratch
        // =============================================================================
        function init() {
            const saved = localStorage.getItem('janus_master_graph');
            if (saved) {
                try {
                    const d = JSON.parse(saved);
                    masterNodeMap = new Map(d.nodes.map(n => [n.id, n]));
                    masterLinks = d.links;
                    showNotification('Loaded saved graph');
                } catch(e) { console.warn('Failed to parse saved graph'); }
            } else {
                // Optionally start with a minimal graph or nothing
                masterNodeMap = new Map();
                masterLinks = [];
            }
            applyFilters();
            updateNav(); // ensure nav is hidden initially
        }

        // =============================================================================
        // RENDER & D3 SIMULATION
        // =============================================================================
        function getCurrentRoot() { return contextStack.length > 0 ? contextStack[contextStack.length-1] : null; }

        function updateView() {
            const rootId = getCurrentRoot();
            // Filter nodes that are visible (parent logic)
            if(!rootId) {
                viewNodes = globalNodes.filter(n => n.parentId == null);
                document.getElementById('nav-context').classList.remove('visible');
            } else {
                const root = globalNodes.find(n => n.id === rootId);
                if(!root) { contextStack.pop(); updateView(); return; }
                root.fx = width/2; root.fy = height/2;
                viewNodes = globalNodes.filter(n => n.id === rootId || n.parentId === rootId);
                updateNav();
            }

            const nodeMap = new Set(viewNodes.map(n => n.id));
            viewLinks = globalLinks
                .filter(l => {
                    const s = l.source.id || l.source;
                    const t = l.target.id || l.target;
                    return nodeMap.has(s) && nodeMap.has(t);
                })
                .map(l => ({
                    source: l.source.id || l.source,
                    target: l.target.id || l.target
                }));

            render();
            updateButtons();
            sim.alpha(1).restart();
        }

        function render() {
            const n = nodeG.selectAll(".node-group").data(viewNodes, d=>d.id);
            n.exit().transition().duration(200).style("opacity", 0).remove();

            const nEnter = n.enter().append("g").attr("class", "node-group")
                .attr("opacity", 0)
                .call(d3.drag().on("start",dragStart).on("drag",dragged).on("end",dragEnd))
                .on("click", clickNode);

            nEnter.transition().duration(400).attr("opacity", 1);

            nEnter.append("circle").attr("class","neuron-aura");
            nEnter.append("circle").attr("class","neuron-core");
            nEnter.append("text").attr("class","emoji").attr("dy", 1);
            nEnter.append("text").attr("class","label");

            const allN = nEnter.merge(n);
            const rootId = getCurrentRoot();

            allN.attr("class", d => {
                let t = d.type || 'default';
                if(!VALID_TYPES.includes(t)) t = 'default';
                return `node-group type-${t} ${d===selectedNode?'selected':''} ${d.id===rootId?'is-root':''}`;
            });

            allN.select(".neuron-core").attr("r", d => d.id===rootId ? 35 : 26);
            allN.select(".neuron-aura").attr("r", d => d.id===rootId ? 80 : 55);
            allN.select(".emoji").text(d => d.emoji || "üí†");
            allN.select(".label").text(d => d.label).attr("dy", 48);

            const l = linkG.selectAll(".link").data(viewLinks, d => (d.source.id||d.source)+"-"+(d.target.id||d.target));
            l.exit().remove();
            const lEnter = l.enter().append("line").attr("class","link");
            const allL = lEnter.merge(l);
            allL.style("stroke", d => {
                const target = viewNodes.find(n=>n.id===(d.target.id||d.target));
                if (target) {
                    let t = target.type || 'default';
                    if(!VALID_TYPES.includes(t)) t = 'default';
                    return `var(--c-${t})`;
                }
                return 'var(--c-default)';
            });

            sim.nodes(viewNodes).on("tick", () => {
                if(isGrid) magneticGrid(sim.alpha());

                allL.each(function(d) {
                    const s = d.source; const t = d.target;
                    const rS = (s.id === rootId ? 35 : 26) + 5;
                    const rT = (t.id === rootId ? 35 : 26) + 5;
                    const dx = t.x - s.x; const dy = t.y - s.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > rS + rT) {
                        const nx = dx / dist; const ny = dy / dist;
                        d3.select(this)
                            .attr("x1", s.x + nx * rS).attr("y1", s.y + ny * rS)
                            .attr("x2", t.x - nx * rT).attr("y2", t.y - ny * rT)
                            .attr("opacity", 0.7);
                    } else { d3.select(this).attr("opacity", 0); }
                });

                allN.attr("transform", d => `translate(${d.x},${d.y})`);
            });
            sim.force("link").links(viewLinks);
        }

        function magneticGrid(alpha) {
            if (!isGrid) return;
            const strength = 0.4 * alpha;
            viewNodes.forEach(d => {
                if (d.fx || d.fy) return;
                d.x += (Math.round(d.x/GRID_SIZE)*GRID_SIZE - d.x) * strength;
                d.y += (Math.round(d.y/GRID_SIZE)*GRID_SIZE - d.y) * strength;
            });
        }

        // =============================================================================
        // EVENT HANDLERS
        // =============================================================================
        function clickNode(e, d) {
            if(e.defaultPrevented) return;
            if(selectedNode === d) { deselect(); }
            else if(!selectedNode) { selectedNode = d; }
            else {
                const s=selectedNode.id, t=d.id;
                const idx = globalLinks.findIndex(l => { const ls = l.source.id||l.source; const lt = l.target.id||l.target; return (ls===s && lt===t) || (ls===t && lt===s); });
                if(idx > -1) globalLinks.splice(idx, 1);
                else globalLinks.push({source:s, target:t});
                animateImpulse(selectedNode, d); selectedNode = d; updateView(); saveData();
            }
            updateButtons(); render();
        }

        function dragStart(e,d) {
            if(!e.active) sim.alphaTarget(0.3).restart();
            d.fx = d.x; d.fy = d.y;
        }
        function dragged(e,d) {
            d.fx = e.x; d.fy = e.y;
        }
        function dragEnd(e,d) {
            if(!e.active) sim.alphaTarget(0);
            if (d.id === getCurrentRoot()) {
                d.fx = width/2; d.fy = height/2;
            } else {
                if (isGrid) {
                    d.fx = Math.round(e.x/GRID_SIZE)*GRID_SIZE;
                    d.fy = Math.round(e.y/GRID_SIZE)*GRID_SIZE;
                } else {
                    d.fx = null; d.fy = null;
                }
            }
            saveData();
        }

        function deselect() { selectedNode=null; updateButtons(); render(); }

        function createNode() {
            const t = d3.zoomTransform(svg.node());
            let x, y;
            const currentParentId = getCurrentRoot();
            if(selectedNode) {
                const a = Math.random()*6.28; x = selectedNode.x + Math.cos(a)*100; y = selectedNode.y + Math.sin(a)*100;
            } else {
                x = (width/2 - t.x)/t.k; y = (height/2 - t.y)/t.k;
            }
            if(isGrid) { x = Math.round(x/GRID_SIZE)*GRID_SIZE; y = Math.round(y/GRID_SIZE)*GRID_SIZE; }
            const newNode = {
                id: Date.now(), label: "Void", emoji: "üåÄ", type: "default", x, y, parentId: currentParentId, isNew: true, chatHistory: []
            };
            globalNodes.push(newNode);
            if(selectedNode) globalLinks.push({source:selectedNode.id, target:newNode.id});
            else if(currentParentId) globalLinks.push({source:currentParentId, target:newNode.id});
            updateView();
            selectedNode = viewNodes.find(n=>n.id===newNode.id);
            updateButtons(); render(); saveData();
            setTimeout(openRename, 50);
            if(navigator.vibrate) navigator.vibrate(20);
        }

        function deleteNode() {
            if(!selectedNode || selectedNode.id === getCurrentRoot()) return;
            const toDelete = new Set([selectedNode.id]);
            let changed = true;
            while(changed) {
                changed = false;
                globalNodes.forEach(n => {
                    if(!toDelete.has(n.id) && toDelete.has(n.parentId)) { toDelete.add(n.id); changed = true; }
                });
            }
            globalNodes = globalNodes.filter(n => !toDelete.has(n.id));
            globalLinks = globalLinks.filter(l => !toDelete.has(l.source.id||l.source) && !toDelete.has(l.target.id||l.target));
            deselect(); updateView(); saveData();
            if(navigator.vibrate) navigator.vibrate([30,30]);
        }

        function dive() {
            if(!selectedNode || selectedNode.id === getCurrentRoot()) return;
            const children = globalNodes.filter(n => n.parentId === selectedNode.id);
            children.forEach(child => {
                child.fx = null; child.fy = null;
                child.x = (width/2) + (Math.random() - 0.5) * 50;
                child.y = (height/2) + (Math.random() - 0.5) * 50;
            });
            contextStack.push(selectedNode.id);
            deselect();
            updateView();
        }

        function ascend() {
            if(contextStack.length===0) return;
            const oldRootId = contextStack.pop();
            const oldRoot = globalNodes.find(n=>n.id===oldRootId);
            if(oldRoot) { 
                oldRoot.fx = null; 
                oldRoot.fy = null;
                oldRoot.vx += (Math.random()-0.5) * 2;
                oldRoot.vy += (Math.random()-0.5) * 2;
            }
            updateView();
        }

        const mainBtn = document.getElementById('main-btn');
        const delHint = document.getElementById('delete-hint');
        let pressTimer, isLongPress = false;

        function handleStart(e) {
            if(e.type === 'touchstart') e.stopPropagation();
            isLongPress = false;
            if(selectedNode) {
                mainBtn.classList.add('holding-delete'); delHint.classList.add('visible');
                pressTimer = setTimeout(() => { isLongPress = true; deleteNode(); }, 800);
            } else { mainBtn.style.transform = "translateX(-50%) scale(0.9)"; }
        }
        function handleEnd(e) {
            e.preventDefault(); clearTimeout(pressTimer);
            mainBtn.classList.remove('holding-delete'); delHint.classList.remove('visible'); mainBtn.style.transform = "";
            if(isLongPress) return;
            if(selectedNode) openRename(); else createNode();
        }
        mainBtn.addEventListener('mousedown', handleStart); mainBtn.addEventListener('touchstart', handleStart);
        mainBtn.addEventListener('mouseup', handleEnd); mainBtn.addEventListener('touchend', handleEnd);

        function openRename() {
            document.getElementById('rename-modal').style.display='flex';
            const inp = document.getElementById('rename-input');
            if(selectedNode.isNew) { inp.value = ""; delete selectedNode.isNew; } else { inp.value = selectedNode.label; }
            inp.focus();
        }

        function confirmRename() {
            const inp = document.getElementById('rename-input');
            if(selectedNode && inp.value.trim() !== "") {
                selectedNode.label = inp.value.trim();
                selectedNode.emoji = "‚è≥";
                render(); saveData();
                aiAnalyze(selectedNode);
            }
            document.getElementById('rename-modal').style.display='none';
        }

        // =============================================================================
        // AI Integration (Gemini)
        // =============================================================================
        async function callGemini(text) {
            if (apiKey) {
                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
                const body = JSON.stringify({ contents: [{ parts: [{ text: text }] }] });
                const res = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: body });
                if (!res.ok) throw new Error("Google API Error");
                return await res.json();
            } else if (BACKEND_URL) {
                const url = `${BACKEND_URL}/api/hrain/sync`;
                const body = JSON.stringify({ text: text });
                const res = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: body });
                if (!res.ok) throw new Error("Janus Backend Error");
                const data = await res.json();
                if(data.error) throw new Error(data.error);
                return data;
            }
            throw new Error("No Connectivity");
        }

        async function aiAnalyze(node) {
            try {
                const prompt = `Classify: "${node.label}". JSON: {"type": "default|danger|warn|info", "emoji": "single_char"}. Context: Danger=bad/risk, Warn=alert, Info=data, Default=neutral.`;
                const d = await callGemini(prompt);
                const json = JSON.parse(d.candidates[0].content.parts[0].text.replace(/```json|```/g,'').trim());
                node.type = json.type; 
                node.emoji = json.emoji; 
                render(); saveData();
            } catch(e) { 
                console.error(e);
                node.emoji = "üîπ"; render(); saveData();
            }
        }

        async function synthNode(btn) {
            if(!selectedNode) return;
            if(btn) { btn.classList.add('loading'); btn.innerText = "PROCESSING..."; }
            try {
                const currentRoot = getCurrentRoot();
                const currentChildren = viewNodes.filter(n => n.parentId === selectedNode.id || (globalLinks.some(l => (l.source.id===selectedNode.id && l.target.id===n.id) || (l.source.id===n.id && l.target.id===selectedNode.id))));
                const prompt = `
                Context: Central Node "${selectedNode.label}".
                Existing Children: ${currentChildren.map(n=>n.label).join(", ") || "None"}.
                Goal: Refine this concept cluster.
                1. RE-EVALUATE PARENT: Provide "parentEmoji" and "parentType" (default/danger/warn/info).
                2. RE-EVALUATE CHILDREN: Provide "updates" array [{label (to match), emoji, type}].
                3. CREATE NEW: Provide "newNodes" array [{label, emoji, type}].
                JSON Only.
                `;
                const d = await callGemini(prompt);
                const raw = d.candidates[0].content.parts[0].text;
                const json = JSON.parse(raw.substring(raw.indexOf('{'), raw.lastIndexOf('}')+1));
                if(json.parentEmoji) selectedNode.emoji = json.parentEmoji;
                if(json.parentType && VALID_TYPES.includes(json.parentType)) selectedNode.type = json.parentType;
                if(json.updates) {
                    json.updates.forEach(u => {
                        const child = currentChildren.find(c => c.label === u.label);
                        if(child) {
                            if(u.emoji) child.emoji = u.emoji;
                            if(u.type && VALID_TYPES.includes(u.type)) child.type = u.type;
                        }
                    });
                }
                if(json.newNodes) {
                    json.newNodes.forEach((n, i) => {
                        const angle = (Math.PI*2/4)*i;
                        let nx = selectedNode.x + Math.cos(angle)*120;
                        let ny = selectedNode.y + Math.sin(angle)*120;
                        if(isGrid) { nx=Math.round(nx/GRID_SIZE)*GRID_SIZE; ny=Math.round(ny/GRID_SIZE)*GRID_SIZE; }
                        const newNode = {
                            id: Date.now()+i, label: n.label, emoji: n.emoji, type: n.type || 'default',
                            x: nx, y: ny, parentId: currentRoot, chatHistory: []
                        };
                        globalNodes.push(newNode);
                        globalLinks.push({source:selectedNode.id, target:newNode.id});
                    });
                }
                updateView(); saveData();
            } catch(e) { 
                console.error(e); 
                showNotification("–ò–ò –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç", true);
            }
            if(btn) { btn.classList.remove('loading'); btn.innerText = "SYNTH"; }
        }

        // =============================================================================
        // CHAT
        // =============================================================================
        function toggleChat() { 
            document.getElementById('chat-panel').classList.toggle('open'); 
            if(document.getElementById('chat-panel').classList.contains('open')) renderChat();
        }
        function renderChat() {
            const c = document.getElementById('chat-msgs');
            c.innerHTML = '';
            if(selectedNode && selectedNode.chatHistory) {
                if(selectedNode.chatHistory.length === 0) addMsgUI('ai', `Uplink established: ${selectedNode.label}. How can I assist?`);
                else selectedNode.chatHistory.forEach(m => addMsgUI(m.role, m.text));
            } else {
                addMsgUI('ai', "Select a node to connect.");
            }
        }
        async function sendChat() {
            const inp = document.getElementById('chat-in');
            const txt = inp.value.trim();
            if(!txt || !selectedNode) return;
            addMsgUI('user', txt);
            if(!selectedNode.chatHistory) selectedNode.chatHistory = [];
            selectedNode.chatHistory.push({role:'user', text:txt});
            inp.value = '';
            try {
                const rootLabel = getCurrentRoot() ? globalNodes.find(n=>n.id===getCurrentRoot()).label : "Root";
                const prompt = `Role: Neural Interface. Context: Node "${selectedNode.label}" inside "${rootLabel}". User says: "${txt}". Reply briefly in Russian.`;
                const d = await callGemini(prompt);
                const reply = d.candidates[0].content.parts[0].text;
                addMsgUI('ai', reply);
                selectedNode.chatHistory.push({role:'ai', text:reply});
                saveData();
            } catch(e) { 
                console.error(e); 
                addMsgUI('ai', "Connection lost.");
                showNotification("–ò–ò –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω", true);
            }
        }
        function addMsgUI(role, txt, id) {
            const d = document.createElement('div');
            d.className = `msg ${role}`; d.innerText = txt;
            if(id) d.id = id;
            const c = document.getElementById('chat-msgs');
            c.appendChild(d); c.scrollTop = c.scrollHeight;
        }

        // =============================================================================
        // UI Helpers
        // =============================================================================
        function updateButtons() {
            mainBtn.className = "ui-interactive " + (selectedNode ? "mode-edit" : "");
            if(selectedNode) {
                mainBtn.style.setProperty('--color-target', `var(--c-${selectedNode.type||'default'})`);
                if(selectedNode.id !== getCurrentRoot()) document.getElementById('btn-dive').classList.add('visible');
                else document.getElementById('btn-dive').classList.remove('visible');
            } else {
                document.getElementById('btn-dive').classList.remove('visible');
                mainBtn.style.removeProperty('--color-target');
            }
        }

        function updateNav() {
            const c = document.getElementById('nav-context');
            const b = document.getElementById('breadcrumbs');
            b.innerHTML = '';
            if(contextStack.length > 0) {
                c.classList.add('visible');
                contextStack.forEach((id, i) => {
                    const n = globalNodes.find(x=>x.id===id);
                    const el = document.createElement('div');
                    el.className = 'crumb ' + (i===contextStack.length-1?'active':'');
                    el.innerText = (n?n.label:'???') + (i<contextStack.length-1?' > ':'');
                    el.onclick = () => jumpToContext(i);
                    b.appendChild(el);
                });
            } else c.classList.remove('visible');
        }

        function jumpToContext(index) {
            while(contextStack.length > index + 1) {
                const id = contextStack.pop();
                const n = globalNodes.find(x=>x.id===id);
                if(n) { 
                    n.fx=null; n.fy=null; 
                    n.x += (Math.random()-0.5) * 50;
                    n.y += (Math.random()-0.5) * 50;
                }
            }
            updateView();
        }

        function toggleGrid() { 
            isGrid=!isGrid; 
            document.body.classList.toggle('grid-active', isGrid); 
            document.getElementById('btn-grid').classList.toggle('active', isGrid); 
            sim.alpha(0.5).restart(); 
        }

        // =============================================================================
        // IO & STORAGE
        // =============================================================================
        function saveData(btn) { 
            const cleanLinks = globalLinks.map(l => ({
                source: l.source.id || l.source,
                target: l.target.id || l.target
            }));
            localStorage.setItem('hrain_v4_graph', JSON.stringify({nodes:globalNodes, links:cleanLinks})); 
            if(btn && !btn.id.includes('btn-save')) { 
                const o=btn.innerText; 
                btn.classList.add('success'); 
                btn.innerText="SAVED!"; 
                setTimeout(()=>{btn.classList.remove('success');btn.innerText=o},1000); 
            } 
        }

        function exportData(btn) {
            saveData();
            const cleanLinks = globalLinks.map(l => ({
                source: l.source.id || l.source,
                target: l.target.id || l.target
            }));
            const dataStr = JSON.stringify({nodes:globalNodes, links:cleanLinks}, null, 2);
            const blob = new Blob([dataStr], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `hrain_data_${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            if(btn) { 
                const o=btn.innerText; 
                btn.classList.add('success'); 
                btn.innerText = "SAVED ‚Üì"; 
                setTimeout(()=>{btn.classList.remove('success');btn.innerText=o}, 1500); 
            } 
        }

        function importData(input) {
            const file = input.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const json = JSON.parse(e.target.result);
                    if(Array.isArray(json.nodes) && Array.isArray(json.links)) {
                        globalNodes = json.nodes;
                        globalLinks = json.links;
                        globalNodes.forEach(n => {
                            if(n.parentId === undefined) n.parentId = null;
                            if(!n.chatHistory) n.chatHistory = [];
                        });
                        selectedNode = null;
                        contextStack = [];
                        updateView();
                        saveData();
                        const btn = document.getElementById('btn-load');
                        if(btn) {
                            const o = btn.innerText;
                            btn.classList.add('success');
                            btn.innerText = "LOADED";
                            setTimeout(()=>{btn.classList.remove('success');btn.innerText=o}, 1500);
                        }
                    } else {
                        alert("Invalid JSON structure");
                    }
                } catch(err) {
                    console.error(err);
                    alert("Error parsing file");
                }
            };
            reader.readAsText(file);
            input.value = '';
        }

        let wipeTimer = null;
        function wipeData(btn) { 
            if(!btn) { localStorage.removeItem('hrain_v4_graph'); location.reload(); return; }
            if(btn.dataset.confirm === "true") {
                btn.innerText = "BYE";
                localStorage.removeItem('hrain_v4_graph'); 
                location.reload();
            } else {
                btn.dataset.confirm = "true";
                btn.innerText = "SURE?";
                btn.style.borderColor = "var(--c-danger)"; 
                btn.style.color = "var(--c-danger)";
                btn.style.boxShadow = "0 0 15px var(--c-danger)";
                if(wipeTimer) clearTimeout(wipeTimer);
                wipeTimer = setTimeout(() => {
                    btn.dataset.confirm = "false";
                    btn.innerText = "WIPE";
                    btn.style.borderColor = ""; 
                    btn.style.color = "";
                    btn.style.boxShadow = "";
                }, 3000);
            }
        }

        // =============================================================================
        // BOOT
        // =============================================================================
        window.onload = () => {
            init();
            // Optional: auto-sync if no saved graph
            if (masterNodeMap.size === 0) {
                syncWithGitHub();
            }
        };
    </script>
</body>
</html>
