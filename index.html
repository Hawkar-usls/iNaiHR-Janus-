<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#05000a">
    <title>iNaiHR: KERNEL</title>
    
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;600;700&family=Orbitron:wght@600;700;900&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-dark: #05000a;
            --c-primary: #d300ff;
            --c-accent: #00e5ff;
            --c-white: #e0ccff;
            --c-red: #ff2a6d;
            --glass: rgba(10, 0, 20, 0.9);
            --border: rgba(211, 0, 255, 0.4);
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: var(--bg-dark);
            font-family: 'Rajdhani', sans-serif; color: var(--c-white);
            user-select: none; -webkit-user-select: none;
        }

        #neural-bg {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 50% 50%, #1a002e, #000);
            z-index: 0; pointer-events: none;
        }
        
        canvas {
            position: absolute; top: 0; left: 0; z-index: 1;
            outline: none; -webkit-tap-highlight-color: transparent;
        }

        /* UI */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
        }
        .pointer-events-auto { pointer-events: auto; }

        #status-bar {
            position: absolute; top: 20px; left: 20px;
            font-family: 'Orbitron'; font-size: 14px; letter-spacing: 2px;
            color: rgba(255,255,255,0.4); text-shadow: 0 0 10px rgba(211,0,255,0.3);
        }
        #status-bar span { color: var(--c-accent); font-weight: bold; }

        .control-group {
            position: absolute; top: 20px; right: 20px;
            display: flex; gap: 8px; flex-wrap: wrap; justify-content: flex-end;
            max-width: 300px;
        }
        .btn {
            background: var(--glass); border: 1px solid var(--border);
            color: var(--c-primary); padding: 8px 12px;
            font-family: 'Orbitron'; font-size: 11px; font-weight: 700;
            backdrop-filter: blur(5px); cursor: pointer; transition: 0.2s;
            text-transform: uppercase; border-radius: 4px;
        }
        .btn:active { background: var(--c-primary); color: #000; transform: translateY(2px); }
        .btn.active-mode { background: var(--c-accent); color: #000; border-color: #fff; box-shadow: 0 0 15px var(--c-accent); }
        .btn:disabled { filter: grayscale(1); opacity: 0.5; }
        .btn-danger { border-color: var(--c-red); color: var(--c-red); }
        .hidden { display: none !important; }

        /* FAB */
        #fab {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 60px; height: 60px; border-radius: 50%;
            background: #1a002e;
            border: 2px solid var(--c-primary); 
            box-shadow: 0 0 20px rgba(211, 0, 255, 0.3);
            display: flex; align-items: center; justify-content: center;
            font-size: 32px; color: var(--c-primary); z-index: 20;
            transition: 0.2s;
        }
        #fab:active { transform: translateX(-50%) scale(0.9); background: var(--c-primary); color: #000; }

        /* MODAL */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 100; display: none;
            align-items: center; justify-content: center; backdrop-filter: blur(4px);
            pointer-events: auto;
        }
        .modal-box {
            width: 85%; max-width: 320px; padding: 25px;
            background: linear-gradient(135deg, #0f001a, #000); 
            border: 1px solid var(--c-accent);
            box-shadow: 0 0 50px rgba(0, 229, 255, 0.15); text-align: center;
            border-radius: 8px;
        }
        .modal-title { font-family: 'Orbitron'; color: var(--c-accent); margin-bottom: 15px; font-size: 14px; }
        input {
            width: 100%; background: rgba(255,255,255,0.05); border: 1px solid #333;
            border-bottom: 2px solid var(--c-accent); color: #fff;
            font-family: 'Rajdhani'; font-size: 20px; font-weight: bold; text-align: center;
            padding: 12px 0; outline: none; margin-bottom: 20px;
        }
        input:focus { background: rgba(0, 229, 255, 0.1); }

        /* NOTIFY */
        #notify {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-family: 'Orbitron'; font-size: 20px; color: var(--c-accent);
            text-shadow: 0 0 10px var(--c-accent); opacity: 0; transition: 0.3s;
            pointer-events: none; z-index: 1000; background: rgba(0,0,0,0.8);
            padding: 10px 20px; border: 1px solid var(--c-accent);
        }
        
        .hint {
            position: absolute; bottom: 10px; width: 100%; text-align: center;
            font-size: 10px; color: rgba(255,255,255,0.3); pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="neural-bg"></div>
    <canvas id="canvas"></canvas>

    <div id="ui-layer">
        <div id="status-bar">iNaiHR <span>NEXUS</span> <span id="node-count">[0]</span></div>
        
        <div class="control-group pointer-events-auto">
            <button class="btn hidden" id="btn-link" onclick="Input.toggleLinkMode()">[LINK]</button>
            <button class="btn hidden" id="btn-ren" onclick="Input.triggerRename()">EDIT</button>
            <button class="btn btn-danger hidden" id="btn-del" onclick="Input.triggerDelete()">DEL</button>
            
            <div style="width: 1px; background: #333; margin: 0 2px;"></div>
            
            <button class="btn" id="btn-synth" onclick="AI.synth()">AI SYNTH</button>
            <button class="btn" onclick="DB.wipe()">[WIPE]</button>
        </div>

        <button id="fab" class="pointer-events-auto" onclick="Input.handleFabClick()">+</button>
        <div class="hint">DBL CLICK: Create | SHIFT+CLICK: Link | DRAG: Move</div>
    </div>

    <div id="notify">SYSTEM READY</div>

    <div id="modal-input" class="modal">
        <div class="modal-box">
            <div class="modal-title" id="modal-title">INPUT DATA</div>
            <input type="text" id="inp-generic" autocomplete="off">
            <div style="display:flex; gap:10px;">
                <button class="btn" style="flex:1; border-color:var(--c-accent); color:var(--c-accent)" id="btn-confirm">OK</button>
                <button class="btn" style="flex:1; border-color:#444; color:#888;" onclick="UI.closeModal()">CANCEL</button>
            </div>
        </div>
    </div>

<script>
// === CONFIGURATION ===
const CONFIG = {
    endpoint: "http://localhost:5000/api/inaihr/generate",
    colors: {
        node: "#d300ff",
        nodeSelected: "#00e5ff",
        nodeAI: "#ffffff",
        link: "rgba(211, 0, 255, 0.3)",
        grid: "rgba(255, 255, 255, 0.03)"
    },
    physics: {
        charge: -400,
        dist: 150,
        collide: 40
    }
};

// === DB CORE ===
const DB = {
    db: null,
    name: 'iNaiHR_NoEmoji_v1', 
    
    async init() {
        return new Promise((resolve) => {
            const req = indexedDB.open(this.name, 1);
            req.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('nodes')) db.createObjectStore('nodes', { keyPath: 'id' });
                if (!db.objectStoreNames.contains('links')) db.createObjectStore('links', { keyPath: 'id' });
            };
            req.onsuccess = (e) => { this.db = e.target.result; resolve(); };
            req.onerror = () => resolve(); 
        });
    },
    async save() {
        if (!this.db) return;
        const tx = this.db.transaction(['nodes', 'links'], 'readwrite');
        const nStore = tx.objectStore('nodes');
        await nStore.clear();
        Graph.nodes.forEach(n => nStore.put({
            id: n.id, label: n.label, x: n.x, y: n.y, isAI: n.isAI
        }));
        const lStore = tx.objectStore('links');
        await lStore.clear();
        Graph.links.forEach(l => lStore.put({
            id: l.id,
            sourceId: l.source.id || l.source,
            targetId: l.target.id || l.target
        }));
    },
    async load() {
        return new Promise((resolve) => {
            if (!this.db) return resolve(null);
            const tx = this.db.transaction(['nodes', 'links'], 'readonly');
            const nReq = tx.objectStore('nodes').getAll();
            const lReq = tx.objectStore('links').getAll();
            tx.oncomplete = () => resolve({ nodes: nReq.result, links: lReq.result });
        });
    },
    wipe() {
        if(confirm("DESTROY ALL NEURAL DATA?")) {
            indexedDB.deleteDatabase(this.name);
            location.reload();
        }
    }
};

// === RENDER CORE ===
const Render = {
    canvas: document.getElementById('canvas'),
    ctx: document.getElementById('canvas').getContext('2d'),
    width: 0, height: 0,
    transform: d3.zoomIdentity,
    
    init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        d3.select(this.canvas).call(d3.zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", (e) => {
                this.transform = e.transform;
                this.requestDraw();
            })
            .filter(event => !event.ctrlKey && !event.button) 
        ).on("dblclick.zoom", null);
    },
    resize() {
        const dpr = window.devicePixelRatio || 1;
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width * dpr;
        this.canvas.height = this.height * dpr;
        this.ctx.scale(dpr, dpr);
        this.requestDraw();
    },
    requestDraw() { requestAnimationFrame(() => this.draw()); },
    
    draw() {
        const ctx = this.ctx;
        const t = this.transform;
        
        ctx.clearRect(0, 0, this.width, this.height);
        ctx.save();
        ctx.translate(t.x, t.y);
        ctx.scale(t.k, t.k);
        
        // Grid
        this.drawGrid(ctx, t);
        
        // Links
        ctx.beginPath();
        ctx.strokeStyle = CONFIG.colors.link;
        ctx.lineWidth = 1.5;
        Graph.links.forEach(l => {
            ctx.moveTo(l.source.x, l.source.y);
            ctx.lineTo(l.target.x, l.target.y);
        });
        ctx.stroke();
        
        // Nodes
        Graph.nodes.forEach(n => {
            const isSel = (n === Graph.selected);
            
            // Glow
            if (isSel) {
                ctx.beginPath();
                ctx.arc(n.x, n.y, 30, 0, Math.PI*2);
                ctx.fillStyle = "rgba(0, 229, 255, 0.15)";
                ctx.fill();
                ctx.strokeStyle = CONFIG.colors.nodeSelected;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            // Core
            ctx.beginPath();
            ctx.arc(n.x, n.y, 10, 0, Math.PI*2);
            ctx.fillStyle = "#000";
            ctx.fill();
            ctx.strokeStyle = isSel ? CONFIG.colors.nodeSelected : (n.isAI ? CONFIG.colors.nodeAI : CONFIG.colors.node);
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Label
            if (t.k > 0.4) {
                ctx.font = `600 12px "Orbitron"`;
                ctx.fillStyle = isSel ? "#fff" : "rgba(255,255,255,0.6)";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(n.label, n.x, n.y + 22);
            }
        });
        
        ctx.restore();
    },
    drawGrid(ctx, t) {
        const sz = 100;
        const w = this.width/t.k, h = this.height/t.k;
        const ox = -t.x/t.k, oy = -t.y/t.k;
        ctx.beginPath();
        ctx.strokeStyle = CONFIG.colors.grid;
        ctx.lineWidth = 1;
        for(let x=Math.floor(ox/sz)*sz; x<ox+w; x+=sz) { ctx.moveTo(x, oy); ctx.lineTo(x, oy+h); }
        for(let y=Math.floor(oy/sz)*sz; y<oy+h; y+=sz) { ctx.moveTo(ox, y); ctx.lineTo(ox+w, y); }
        ctx.stroke();
    }
};

// === LOGIC KERNEL ===
const Graph = {
    nodes: [], links: [], nodeMap: new Map(),
    selected: null, simulation: null,
    
    init(data) {
        if (data) {
            this.nodes = data.nodes;
            this.links = data.links.map(l => ({
                id: l.id, source: l.sourceId, target: l.targetId
            }));
        }
        this.sim();
        this.update();
    },
    
    sim() {
        this.simulation = d3.forceSimulation(this.nodes)
            .force("link", d3.forceLink(this.links).id(d=>d.id).distance(CONFIG.physics.dist))
            .force("charge", d3.forceManyBody().strength(CONFIG.physics.charge))
            .force("collide", d3.forceCollide(CONFIG.physics.collide))
            .on("tick", () => Render.requestDraw());
    },
    
    update() {
        this.simulation.nodes(this.nodes);
        this.simulation.force("link").links(this.links);
        this.simulation.alpha(1).restart();
        this.nodeMap.clear();
        this.nodes.forEach(n => this.nodeMap.set(n.id, n));
        
        document.getElementById('node-count').innerText = `[${this.nodes.length}]`;
        DB.save();
        Render.requestDraw();
    },
    
    // CRUD
    addNode(x, y, label, isAI=false) {
        const n = { id: Date.now()+Math.random(), x, y, label, isAI };
        this.nodes.push(n);
        this.update();
        return n;
    },
    
    toggleLink(n1, n2) {
        if (n1 === n2) return;
        const existIdx = this.links.findIndex(l => 
            (l.source === n1 && l.target === n2) || (l.source === n2 && l.target === n1)
        );
        
        if (existIdx >= 0) {
            this.links.splice(existIdx, 1);
            UI.notify("LINK BROKEN");
        } else {
            this.links.push({ id: `${n1.id}-${n2.id}`, source: n1, target: n2 });
            UI.notify("LINKED");
        }
        this.update();
    },
    
    deleteNode(n) {
        this.nodes = this.nodes.filter(x => x !== n);
        this.links = this.links.filter(l => l.source !== n && l.target !== n);
        this.selected = null;
        this.update();
        Input.updateUI();
    },
    
    getAIContext(n) {
        const neighbors = this.links
            .filter(l => l.source === n || l.target === n)
            .map(l => (l.source === n ? l.target : l.source));
        return `NODE: "${n.label}"\nCONNECTED TO: [${neighbors.map(x=>x.label).join(", ")}]`;
    }
};

// === INPUT SYSTEM ===
const Input = {
    isLinkMode: false,
    
    init() {
        const cvs = d3.select("#canvas");
        
        // 1. Dragging
        cvs.call(d3.drag()
            .subject(e => {
                const t = Render.transform;
                const wx = (e.x - t.x)/t.k, wy = (e.y - t.y)/t.k;
                return Graph.nodes.find(n => Math.hypot(n.x-wx, n.y-wy) < 30);
            })
            .on("start", e => {
                if (!e.active) Graph.simulation.alphaTarget(0.3).restart();
                e.subject.fx = e.subject.x;
                e.subject.fy = e.subject.y;
                Graph.selected = e.subject; 
                Input.updateUI();
            })
            .on("drag", e => {
                e.subject.fx = e.x;
                e.subject.fy = e.y;
            })
            .on("end", e => {
                if (!e.active) Graph.simulation.alphaTarget(0);
                e.subject.fx = null; e.subject.fy = null;
                DB.save();
            })
        );
        
        // 2. Click (Select / Link)
        cvs.on("click", (e) => {
            if (e.defaultPrevented) return; 
            
            const t = Render.transform;
            const [mx, my] = d3.pointer(e);
            const wx = (mx - t.x)/t.k, wy = (my - t.y)/t.k;
            
            const clicked = Graph.nodes.find(n => Math.hypot(n.x-wx, n.y-wy) < 30);
            
            if (clicked) {
                if (Graph.selected && (e.shiftKey || Input.isLinkMode)) {
                    Graph.toggleLink(Graph.selected, clicked);
                    if (Input.isLinkMode) Input.toggleLinkMode(); 
                } else {
                    Graph.selected = clicked;
                }
            } else {
                Graph.selected = null;
            }
            Input.updateUI();
        });
        
        // 3. Double Click (Create)
        cvs.on("dblclick", (e) => {
            const t = Render.transform;
            const [mx, my] = d3.pointer(e);
            const wx = (mx - t.x)/t.k, wy = (my - t.y)/t.k;
            
            // Only create if empty space
            if (!Graph.nodes.find(n => Math.hypot(n.x-wx, n.y-wy) < 30)) {
                UI.openModal("CREATE NODE", (lbl) => {
                    const n = Graph.addNode(wx, wy, lbl);
                    Graph.selected = n;
                    Input.updateUI();
                });
            }
        });
    },
    
    updateUI() {
        const sel = Graph.selected;
        document.getElementById('btn-link').classList.toggle('hidden', !sel);
        document.getElementById('btn-ren').classList.toggle('hidden', !sel);
        document.getElementById('btn-del').classList.toggle('hidden', !sel);
        document.getElementById('btn-synth').style.opacity = sel ? "1" : "0.5";
    },
    
    handleFabClick() {
        if (Graph.selected) {
            UI.openModal("ADD CHILD", (lbl) => {
                const p = Graph.selected;
                const c = Graph.addNode(p.x+(Math.random()-0.5)*50, p.y+50, lbl);
                Graph.toggleLink(p, c);
            });
        } else {
            // Simulate center click
            const t = Render.transform;
            UI.openModal("NEW ROOT", (lbl) => {
                const n = Graph.addNode((Render.width/2 - t.x)/t.k, (Render.height/2 - t.y)/t.k, lbl);
                Graph.selected = n;
                Input.updateUI();
            });
        }
    },
    
    toggleLinkMode() {
        this.isLinkMode = !this.isLinkMode;
        const btn = document.getElementById('btn-link');
        if (this.isLinkMode) {
            btn.classList.add('active-mode');
            btn.innerText = "SELECT TARGET";
            UI.notify("SELECT NODE TO LINK");
        } else {
            btn.classList.remove('active-mode');
            btn.innerText = "[LINK]";
        }
    },
    
    triggerRename() {
        if (!Graph.selected) return;
        UI.openModal("RENAME", (val) => {
            Graph.selected.label = val;
            Graph.update();
        }, Graph.selected.label);
    },
    
    triggerDelete() {
        if (Graph.selected && confirm("DELETE?")) Graph.deleteNode(Graph.selected);
    }
};

// === AI SYSTEM ===
const AI = {
    async synth() {
        if (!Graph.selected) return UI.notify("SELECT A NODE FIRST");
        
        const btn = document.getElementById('btn-synth');
        btn.disabled = true; btn.innerText = "PROCESSING...";
        
        // --- STRICT PROMPT NO EMOJIS ---
        const prompt = `
        ${Graph.getAIContext(Graph.selected)}
        TASK: Generate 3 related sub-concepts (JSON).
        FORMAT: [{"text":"Name"}, ...]
        CONSTRAINT: USE ONLY TEXT. NO EMOJIS. NO SYMBOLS.
        `;
        
        try {
            const res = await fetch(CONFIG.endpoint, {
                method: 'POST',
                headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ prompt })
            });
            if (!res.ok) throw new Error("API Fail");
            
            const arr = await res.json();
            if (!Array.isArray(arr)) throw new Error("Bad Data");
            
            const parent = Graph.selected;
            arr.forEach(item => {
                // FORCE CLEAN TEXT
                const cleanText = item.text.replace(/[^\x00-\x7Fа-яА-Я0-9 ]/g, "");
                
                const node = Graph.addNode(
                    parent.x + (Math.random()-0.5)*150,
                    parent.y + (Math.random()-0.5)*150,
                    cleanText || "Node",
                    true
                );
                Graph.toggleLink(parent, node);
            });
            UI.notify(`GENERATED ${arr.length} NODES`);
            
        } catch(e) {
            console.error(e);
            UI.notify("JANUS ERROR");
        } finally {
            btn.disabled = false; btn.innerText = "AI SYNTH";
        }
    }
};

// === UI HELPERS ===
const UI = {
    cb: null,
    openModal(title, callback, val="") {
        document.getElementById('modal-title').innerText = title;
        const div = document.getElementById('modal-input');
        const inp = document.getElementById('inp-generic');
        inp.value = val;
        this.cb = callback;
        div.style.display = "flex";
        inp.focus();
        
        document.getElementById('btn-confirm').onclick = () => {
            if(inp.value.trim()) { this.cb(inp.value.trim()); this.closeModal(); }
        };
    },
    closeModal() {
        document.getElementById('modal-input').style.display = "none";
        this.cb = null;
    },
    notify(msg) {
        const n = document.getElementById('notify');
        n.innerText = msg; n.style.opacity = 1;
        setTimeout(()=>n.style.opacity=0, 2000);
    }
};

// === BOOT ===
(async()=>{
    await DB.init();
    const d = await DB.load();
    Render.init();
    Graph.init(d);
    Input.init();
    document.fonts.ready.then(()=>Render.requestDraw());
})();
</script>
</body>
</html>
